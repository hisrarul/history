## Database Secrets Engine (HVD)
#### Database secrets engine

In this track, you will migrate a Python web app from using static credentials for a MySQL database to using those generated by Vault. This track workflow based and is designed to address both Producer and Consumer use cases.

In this first challenge, you will run the Python web app with static credentials obtained from a configuration file.

#### Database secret engine
The Vault Database Secrets Engine allows you to dynamically generate database credentials for various database systems. This capability is crucial for enhancing security and operational efficiency by automating the management of database credentials.

| Key Features |	Description |
|------------|------------|
| Dynamic Credentials	| Vault can generate database credentials dynamically, ensuring that each application or user gets unique credentials with a limited lifespan. This reduces the risk of credential leakage and misuse. |
| Credential Rotation |	Vault can automatically rotate database credentials at regular intervals, ensuring that credentials are always fresh and reducing the risk of long-term credential exposure.
| Revocation	Vault | can revoke database credentials on demand, providing an immediate way to invalidate credentials if they are compromised or no longer needed.
| Support for Multiple Databases |	The Database Secrets Engine supports a wide range of database systems, including MySQL, PostgreSQL, Microsoft SQL Server, Oracle, and more.
| Lease Management |	Vault manages the lifecycle of database credentials through leases, automatically revoking credentials when their lease expires.


#### Step 1: Vault Verification
```bash
vault version -> Vault v1.15.6+ent
vault status
```

#### Step 2: Application Configuration
Inspect `config.ini` file
```text
[DEFAULT]
LogLevel = WARN

[DATABASE]
Address=127.0.0.1
Port=3306
User=root
Password=password
Database=my_app

[VAULT]
Enabled = False
DynamicDBCreds = False
DynamicDBCredsPath = database/creds/recordsApp
ProtectRecords=False
Address=https://127.0.0.1:8200
#Address=vault.service.consul
Token=hvs.aPjye0Up6QR6kErbaWAj2a91
KeyPath=lob_a/workshop/transit
KeyName=customer-key
```

#### Step 3: Start the Python App
Content of `app.py` and Start `python3 app.py &`
```python
from flask import Flask, request, render_template, abort

from datetime import datetime
import configparser
import json
import logging
import logging.config

import db_client

dbc = None
vclient = None

log_level = {
  'CRITICAL' : 50,
  'ERROR'          : 40,
  'WARN'         : 30,
  'INFO'           : 20,
  'DEBUG'          : 10
}

logger = logging.getLogger('app')

app = Flask(__name__)
app.config['TEMPLATES_AUTO_RELOAD'] = True

def read_config():
  conf = configparser.ConfigParser()
  with open('config.ini') as f:
    conf.read_file(f)
  return conf

@app.route('/customers', methods=['GET'])
def get_customers():
    global dbc
    customers = dbc.get_customer_records()
    logger.debug('Customers: {}'.format(customers))
    return json.dumps(customers)

@app.route('/customer', methods=['GET'])
def get_customer():
    global dbc
    cust_no = request.args.get('cust_no')
    if not cust_no:
      return '<html><body>Error: cust_no is a required argument for the customer endpoint.</body></html>', 500
    record = dbc.get_customer_record(cust_no)
    #logger.debug('Request: {}'.format(request))
    return json.dumps(record)

@app.route('/customers', methods=['POST'])
def create_customer():
    global dbc
    logging.debug("Form Data: {}".format(dict(request.form)))
    customer = {k:v for (k,v) in dict(request.form).items()}
    for k,v in customer.items():
      if type(v) is list:
        customer[k] = v[0]
    logging.debug('Customer: {}'.format(customer))
    if 'create_date' not in customer.keys():
      customer['create_date'] = datetime.now().isoformat()
    new_record = dbc.insert_customer_record(customer)
    logging.debug('New Record: {}'.format(new_record))
    return json.dumps(new_record)

@app.route('/customers', methods=['PUT'])
def update_customer():
    global dbc
    logging.debug('Form Data: {}'.format(dict(request.form)))
    customer = {k:v for (k,v) in dict(request.form).items()}
    logging.debug('Customer: {}'.format(customer))
    new_record = dbc.update_customer_record(customer)
    logging.debug('New Record: {}'.format(new_record))
    return json.dumps(new_record)

@app.route('/', methods=['GET'])
def index():
    return render_template('index.html')

@app.route('/records', methods=['GET'])
def records():
    records = json.loads(get_customers())
    return render_template('records.html', results = records)

@app.route('/dbview', methods=['GET'])
def dbview():
    global dbc
    records = dbc.get_customer_records(raw = True)
    return render_template('dbview.html', results = records)

@app.route('/add', methods=['GET'])
def add():
    return render_template('add.html')

@app.route('/add', methods=['POST'])
def add_submit():
    records = create_customer()
    return render_template('records.html', results = json.loads(records), record_added = True)

@app.route('/update', methods=['GET'])
def update():
    return render_template('update.html')

@app.route('/update', methods=['POST'])
def update_submit():
    records = update_customer()
    return render_template('records.html', results = json.loads(records), record_updated = True)

if __name__ == '__main__':
  logger.warn('In Main...')
  conf = read_config()
  
  logging.basicConfig(
    level=log_level[conf['DEFAULT']['LogLevel']],
    format='%(asctime)s - %(levelname)8s - %(name)9s - %(funcName)15s - %(message)s'
  )

  try:
    dbc = db_client.DbClient()

    if conf.has_section('VAULT'):
      if conf['VAULT']['Enabled'].lower() == 'true':
        logger.info('Vault is enabled...')
        dbc.init_vault(addr=conf['VAULT']['Address'], token=conf['VAULT']['Token'], path=conf['VAULT']['KeyPath'], key_name=conf['VAULT']['KeyName'])
        if conf['VAULT']['DynamicDBCreds'].lower() == 'true':
          logger.debug('db_auth')
          dbc.vault_db_auth(conf['VAULT']['DynamicDBCredsPath'])
          logger.info('using dynamic credentials from Vault: %s with password %s', dbc.username, dbc.password)
          dbc.init_db(uri=conf['DATABASE']['Address'], 
          prt=conf['DATABASE']['Port'], 
          uname=dbc.username, 
          pw=dbc.password, 
          db=conf['DATABASE']['Database']
          )
      
      if dbc.is_initialized is False: # we didn't use dynamic credentials
        logger.info('Using DB credentials from config.ini...')
        dbc.init_db(
          uri=conf['DATABASE']['Address'], 
          prt=conf['DATABASE']['Port'], 
          uname=conf['DATABASE']['User'], 
          pw=conf['DATABASE']['Password'], 
          db=conf['DATABASE']['Database']
        )  
    logger.info('Starting Flask server on {} listening on port {}'.format('0.0.0.0', '5000'))
    app.run(host='0.0.0.0', port=5000)

  except Exception as e:
    logging.error("There was an error starting the server: {}".format(e))
```

## In this challenge, you will enable the database secrets engine for use with a MySQL database.

#### How it works
```text
The database secrets engine generates access credentials on the fly based on predefined roles. It supports various databases through a plugin interface, including built-in types and a framework for custom types. This allows services to request credentials from Vault instead of hardcoding them, making use of Vault's leasing mechanism to easily update keys. These credentials are called dynamic roles or dynamic secrets.

Each service accesses the database with unique credentials, simplifying the approach to auditing. If any suspicious data access occurs, you can trace it back to the specific service instance using the SQL username.

Vault has an internal revocation system to invalidate users shortly after their lease expires, ensuring security.

Once you are comfortable with Vault, this method becomes a standard pattern to follow. It ensures a consistent, secure way of handling database credentials across all services, enhancing security and simplifying credential management
```

#### Step 1: Enable the Database Secret Engine
1. Before we enable the database secrets engine, let's pull a list of any engines that already exist. to do so, run the following command: `vault secrets list`
2. Now let's enable the database secrets engine. Run the following command: `vault secrets enable database`

## In this challenge, you will configure the database secrets engine you enabled in the previous challenge on the default path "database" to work with the local instance of the MySQL database. Note that multiple instances of the database secrets engine can be configured for different lines of business that might each have multiple databases.

#### Step 2: Configure the MySQL Database Plugin
1. Configure the MySQL database plugin with the necessary connection details. You will need the database connection URL, username, and password. You can read more about this in the [Database secrets engine (API)](https://developer.hashicorp.com/vault/api-docs/secret/databases) and [MySQL/MariaDB database secrets engine](https://developer.hashicorp.com/vault/docs/secrets/databases/mysql-maria) documentation. 
```bash vault write database/config/mysql \
  plugin_name=mysql-database-plugin \
  connection_url="{{username}}:{{password}}@tcp(localhost:3306)/" \
  allowed_roles="recordsApp" \
  username="hashicorp" \
  password="Password123"
```
2. You can also verify that the plugin is operating correctly by running the following: `vault read database/config/mysql`
3. Test the credentials `mysql -u hashicorp -pPassword123`

#### Step 3: Rotate the credentials
To secure Vaultâ€™s root credential after it is configured, Vault provides an endpoint to rotate the credential. This will replace the manually entered credential with a credential that only this Vault configuration knows. For this reason, do not use the same root credential in more than one location, even within the same Vault cluster. Immediate root credential rotation reduces the risk of someone else accessing and using that credential.

1. Let's force a rotation with the following command: `vault write -force database/rotate-root/mysql`
2. Now, try to log in to the MySQL server with the same command as before: `mysql -u hashicorp -pPassword123`

#### Step 4: Create a role
We'll now create the role recordsApp, which will be used to generate dynamic credentials for the database. These credentials will be assigned an initial lease of 1 hour and can be renewed for up to 24 hours after initial issuance.

Roles determine how database credentials (like usernames and passwords) are created. You can set up different roles for different access levels.

For instance, you might have one role for read-only access and another for read-write access to a MySQL server. The main Vault user, known as the root user, must have the right permissions in the database to handle all these roles.

1. Run the following command to create the role:
```bash
vault write database/roles/recordsApp \
  db_name=mysql \
  creation_statements="CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}';GRANT ALL ON my_app.* TO '{{name}}'@'%';" \
  default_ttl="1h" \
  max_ttl="24h"
```
The database secrets engine is now configured to talk to the MySQL server and is allowed to create users with the `recordsApp` role.

## In this challenge, you will dynamically generate credentials (username and password) against the role you configured in the previous challenge. You will then connect to the MySQL server with the credentials generated by Vault.

#### Introduction
Now that you have configured the database secrets engine with a connection and a role for the MySQL database, you can dynamically generate short-lived credentials against the role and use them to connect to the database.

#### Step 1: Generate Credentials

1. First, generate credentials for the role, recordsApp, with this command: `vault read database/creds/recordsApp`
2. You can look up the properties of a lease with the following command. This helps check TTL, expiration time, and whether it can be renewed. Copy the lease_id from the previous output and run the following command: `vault write sys/leases/lookup lease_id=<lease_id>`

The TTL will tell you the remaining time to live of the lease and the credentials. When the lease expires, Vault will delete the credentials from MySQL.

Extending the lease will only work if the lease has not yet expired. Additionally, the lease on the credentials cannot be extended beyond the original time of their creation plus the duration given by the max_ttl parameter of the role. If either of these conditions apply, you will get an error.

#### Step 2: Test the credentials
Now we'll log in to the MySQL server with the credentials we generated above. Run the following command replace the username field and paste in the password when prompted (it will be hidden): `mysql -u <username> -p`

#### Step 3: Revoke the credentials
1. Finally, let's explore how you can revoke database credentials. Run the revoke command below and replace the lease_id field with what you generated previously: `vault write sys/leases/revoke lease_id=<lease_id>`
2. You can try to log in again to test if this worked: `mysql -u <username> -p`

## In this challenge, you will update the Python web application to use database credentials generated by Vault's database secrets engine. Now all you need to do is edit the web app's config.ini file and restart it.

#### Introduction
In the final challenge of this lab, you will migrate the Python web application to use database credentials generated by Vault's Database secrets engine.

#### Step 1: Reconfigure the application
```text
[VAULT]
Enabled = True
DynamicDBCreds = True
DynamicDBCredsPath = database/creds/recordsApp
```

#### Step 2: Restart the Application
```bash
cd /opt/vcdl/files/transit-app-example/backend
python3 app.py &
```

## In this challenge, you will be tasked with recreating a new role to replace the existing one for the application.

#### Introduction
As part of our commitment to top-notch security and compliance with audit requirements, we have an exciting challenge for you! Here's your mission:

Check to make sure the appropriate secrets engine is enabled.
```bash
vault secrets list
vault secrets enable <secrets_engine>
```

Modify the MySQL database plugin to allow the vaultUser role.
```bash
vault write database/config/mysql \
  plugin_name=mysql-database-plugin \
  connection_url="{{username}}:{{password}}@tcp(localhost:3306)/" \
  allowed_roles="recordApp,vaultUser" \
  username="hashicorp" \
  password="Password123"
```

Create a new role called vaultUser.
```bash
vault write database/roles/vaultUser db_name=mysql creation_statements="CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}';GRANT ALL ON my_app.* TO '{{name}}'@'%';" default_ttl="1h" max_ttl="24h"
```

Revoke the existing recordsApp credentials.
```bash
vault write sys/leases/revoke lease_id=<lease_id>
vault lease revoke -prefix database/creds/recordsApp
```

Generate credentials for the vaultUser role.
```bash
vault read database/creds/<role_name>
```

Migrate the application to use the new role and credentials. This will require you to modify the config.ini file.
* Update config.ini file with new role

Run the Python web app!
```bash
cd /opt/vcdl/files/transit-app-example/backend
python3 app.py &
```

You should see the web app up and running.
